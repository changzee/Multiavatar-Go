package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

const (
	svgDir     = "svg"
	outputFile = "parts.go" // Output to the current directory
)

func main() {
	const envPath = `<path d="M33.83,33.83a115.5,115.5,0,1,1,0,163.34,115.49,115.49,0,0,1,0-163.34Z" style="fill:#01;"/>`
	const headPath = `<path d="m115.5 51.75a63.75 63.75 0 0 0-10.5 126.63v14.09a115.5 115.5 0 0 0-53.729 19.027 115.5 115.5 0 0 0 128.46 0 115.5 115.5 0 0 0-53.729-19.029v-14.084a63.75 63.75 0 0 0 53.25-62.881 63.75 63.75 0 0 0-63.65-63.75 63.75 63.75 0 0 0-0.09961 0z" style="fill:#000;"/>`

	var finalParts [16]map[string]string
	for i := range finalParts {
		finalParts[i] = make(map[string]string)
	}

	files, err := os.ReadDir(svgDir)
	if err != nil {
		panic(fmt.Errorf("failed to read svg directory: %w", err))
	}

	// 匹配带有 class 的常见 SVG 元素（path|g|circle|ellipse|rect|polygon|polyline|line）
	pathRegex := regexp.MustCompile(`<(?:(?:path)|(?:g)|(?:circle)|(?:ellipse)|(?:rect)|(?:polygon)|(?:polyline)|(?:line))[^>]*?class="([^"]+)"[^>]*?\/?>`)

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), "_final.svg") {
			continue
		}

		id := file.Name()[0:2]
		fmt.Printf("Processing %s (ID: %s)...\n", file.Name(), id)

		content, err := os.ReadFile(filepath.Join(svgDir, file.Name()))
		if err != nil {
			panic(fmt.Errorf("failed to read file %s: %w", file.Name(), err))
		}

		// 归类映射：将多样的 class 归并到 6 大部件
		classMap := map[string]string{
			// clothes
			"clothes": "clo", "clo": "clo", "shirt": "clo", "hoodie": "clo", "jacket": "clo", "coat": "clo",
			// mouth
			"mouth": "mouth", "lips": "mouth", "smile": "mouth",
			// eyes
			"eyes": "eyes", "eye": "eyes", "iris": "eyes", "pupil": "eyes", "eyelid": "eyes",
			// top/hair/hats
			"top": "top", "hair": "top", "cap": "top", "hat": "top", "beard": "top", "mustache": "top",
			// env/head 固定由常量注入，不从文件抽
		}

		partsMerged := map[string]string{
			"clo":   "",
			"mouth": "",
			"eyes":  "",
			"top":   "",
		}

		matches := pathRegex.FindAllStringSubmatch(string(content), -1)
		for _, m := range matches {
			fullTag := m[0]
			className := strings.TrimSpace(m[1])
			key := classMap[className]
			if key != "" {
				partsMerged[key] += fullTag
			}
		}

		intID := 0
		fmt.Sscanf(id, "%d", &intID)

		finalParts[intID]["env"] = envPath
		finalParts[intID]["head"] = headPath
		finalParts[intID]["clo"] = partsMerged["clo"]
		finalParts[intID]["mouth"] = partsMerged["mouth"]
		finalParts[intID]["eyes"] = partsMerged["eyes"]
		finalParts[intID]["top"] = partsMerged["top"]
	}

	var sb strings.Builder
	sb.WriteString("// Code generated by go run build/main.go; DO NOT EDIT.\n\n")
	sb.WriteString("package multiavatar\n\n")
	sb.WriteString("import (\n\t \"strings\"\n)\n")

	// Generate parts data as a single large string constant for simplicity and to avoid complex types.
	sb.WriteString("const partsData = `" +
		strings.Join(partsToStrings(finalParts), "\n") +
		"`\n\n")

	sb.WriteString(`
var parts [][]string

func init() {
	parts = make([][]string, 16)
	lines := strings.Split(strings.TrimSpace(partsData), "\n")
	for i, line := range lines {
		id := i / 6
		if parts[id] == nil {
			parts[id] = make([]string, 0, 6)
		}
		parts[id] = append(parts[id], line)
	}
}
`)

	err = os.WriteFile(outputFile, []byte(sb.String()), 0644)
	if err != nil {
		panic(fmt.Errorf("failed to write to %s: %w", outputFile, err))
	}

	fmt.Printf("Successfully generated %s\n", outputFile)
}

func partsToStrings(parts [16]map[string]string) []string {
	var result []string
	partOrder := []string{"env", "clo", "head", "mouth", "eyes", "top"}
	for i := 0; i < 16; i++ {
		for _, partName := range partOrder {
			svgData := parts[i][partName]
			// Replace backticks just in case, to not break the raw string literal
			result = append(result, strings.ReplaceAll(svgData, "`", "'"))
		}
	}
	return result
}
